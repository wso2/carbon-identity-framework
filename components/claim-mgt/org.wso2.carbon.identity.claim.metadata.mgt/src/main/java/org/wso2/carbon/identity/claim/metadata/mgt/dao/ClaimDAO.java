/*
 * Copyright (c) 2016-2025, WSO2 LLC. (http://www.wso2.com).
 *
 * WSO2 LLC. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.wso2.carbon.identity.claim.metadata.mgt.dao;

import org.apache.commons.lang.StringUtils;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;
import org.wso2.carbon.identity.claim.metadata.mgt.exception.ClaimMetadataClientException;
import org.wso2.carbon.identity.claim.metadata.mgt.exception.ClaimMetadataException;
import org.wso2.carbon.identity.claim.metadata.mgt.model.Claim;
import org.wso2.carbon.identity.claim.metadata.mgt.util.SQLConstants;
import org.wso2.carbon.identity.core.util.IdentityDatabaseUtil;
import org.wso2.carbon.utils.DBUtils;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static org.wso2.carbon.identity.claim.metadata.mgt.util.ClaimConstants.CANONICAL_VALUES_PROPERTY;
import static org.wso2.carbon.identity.claim.metadata.mgt.util.ClaimConstants.CANONICAL_VALUE_PREFIX;
import static org.wso2.carbon.identity.claim.metadata.mgt.util.ClaimConstants.ErrorMessage.ERROR_CODE_MAPPED_TO_INVALID_LOCAL_CLAIM_URI;
import static org.wso2.carbon.identity.claim.metadata.mgt.util.ClaimConstants.SUB_ATTRIBUTES_PROPERTY;
import static org.wso2.carbon.identity.claim.metadata.mgt.util.ClaimConstants.SUB_ATTRIBUTE_PREFIX;

/**
 *
 * Data access object for org.wso2.carbon.identity.claim.metadata.mgt.model.Claim
 *
 */
public class ClaimDAO {

    private static final Log log = LogFactory.getLog(ClaimDAO.class);

    public Map<Integer, Claim> getClaims(Connection connection, String claimDialectURI, int tenantId) throws
            ClaimMetadataException {

        Map<Integer, Claim> claimMap = new HashMap<>();

        PreparedStatement prepStmt = null;
        ResultSet rs = null;

        String query = SQLConstants.GET_CLAIMS_BY_DIALECT;

        try {
            prepStmt = connection.prepareStatement(query);
            prepStmt.setString(1, claimDialectURI);
            prepStmt.setInt(2, tenantId);
            prepStmt.setInt(3, tenantId);
            rs = prepStmt.executeQuery(); // TODO : Get the logic reviewed : using executeQuery in a transaction.

            while (rs.next()) {
                String claimURI = rs.getString(SQLConstants.CLAIM_URI_COLUMN);
                int claimId = rs.getInt(SQLConstants.ID_COLUMN);
                claimMap.put(claimId, new Claim(claimDialectURI, claimURI));
            }

        } catch (SQLException e) {
            throw new ClaimMetadataException("Error while listing claims for dialect " + claimDialectURI, e);
        } finally {
            IdentityDatabaseUtil.closeResultSet(rs);
            IdentityDatabaseUtil.closeStatement(prepStmt);
        }

        return claimMap;
    }

    public int addClaim(Connection connection, String claimDialectURI, String claimURI, int tenantId) throws
            ClaimMetadataException {

        PreparedStatement prepStmt = null;
        ResultSet rs = null;

        int claimId = 0;
        String query = SQLConstants.ADD_CLAIM;
        try {
            String dbProductName = connection.getMetaData().getDatabaseProductName();
            prepStmt = connection.prepareStatement(query, new String[]{DBUtils.getConvertedAutoGeneratedColumnName
                    (dbProductName, SQLConstants.ID_COLUMN)});

            prepStmt.setString(1, claimDialectURI);
            prepStmt.setInt(2, tenantId);
            prepStmt.setString(3, claimURI);
            prepStmt.setInt(4, tenantId);
            prepStmt.executeUpdate();

            rs = prepStmt.getGeneratedKeys();

            if (rs.next()) {
                claimId = rs.getInt(1);
            }
        } catch (SQLException e) {
            throw new ClaimMetadataException("Error while adding claim " + claimURI + " to dialect " +
                    claimDialectURI, e);
        } finally {
            IdentityDatabaseUtil.closeResultSet(rs);
            IdentityDatabaseUtil.closeStatement(prepStmt);
        }

        return claimId;
    }

    public void removeClaim(String claimDialectURI, String localClaimURI, int tenantId) throws
            ClaimMetadataException {

        Connection connection = IdentityDatabaseUtil.getDBConnection();
        PreparedStatement prepStmt = null;

        String query = SQLConstants.REMOVE_CLAIM;
        try {
            prepStmt = connection.prepareStatement(query);
            prepStmt.setString(1, claimDialectURI);
            prepStmt.setInt(2, tenantId);
            prepStmt.setString(3, localClaimURI);
            prepStmt.setInt(4, tenantId);
            prepStmt.executeUpdate();
            IdentityDatabaseUtil.commitTransaction(connection);
        } catch (SQLException e) {
            IdentityDatabaseUtil.rollbackTransaction(connection);
            throw new ClaimMetadataException("Error while deleting claim " + localClaimURI + " from dialect" +
                    claimDialectURI, e);
        } finally {
            IdentityDatabaseUtil.closeStatement(prepStmt);
            IdentityDatabaseUtil.closeConnection(connection);
        }
    }

    public int getClaimId(Connection connection, String claimDialectURI, String claimURI, int tenantId) throws
            ClaimMetadataException {

        PreparedStatement prepStmt = null;
        ResultSet rs = null;

        int claimId = 0;
        String query = SQLConstants.GET_CLAIM_ID;
        try {
            prepStmt = connection.prepareStatement(query);
            prepStmt.setString(1, claimDialectURI);
            prepStmt.setInt(2, tenantId);
            prepStmt.setString(3, claimURI);
            prepStmt.setInt(4, tenantId);
            rs = prepStmt.executeQuery();

            while (rs.next()) {
                claimId = rs.getInt(SQLConstants.ID_COLUMN);
            }
        } catch (SQLException e) {
            throw new ClaimMetadataException("Error while retrieving ID for claim " + claimURI + " in dialect "
                    + claimDialectURI, e);
        } finally {
            IdentityDatabaseUtil.closeResultSet(rs);
            IdentityDatabaseUtil.closeStatement(prepStmt);
        }

        if (claimId == 0) {
            // TODO : Throw runtime exception?
            throw new ClaimMetadataClientException(ERROR_CODE_MAPPED_TO_INVALID_LOCAL_CLAIM_URI.getCode(),
                    String.format(ERROR_CODE_MAPPED_TO_INVALID_LOCAL_CLAIM_URI.getMessage(), claimURI,
                            claimDialectURI));
        }

        return claimId;
    }

    public Map<String, String> getClaimProperties(Connection connection, int claimId, int tenantId)
            throws ClaimMetadataException {

        Map<String, String> claimProperties = new HashMap<>();

        String query = SQLConstants.GET_CLAIM_PROPERTIES;

        try (PreparedStatement prepStmt = connection.prepareStatement(query)) {
            ArrayList<String> subAttributes = new ArrayList<>();
            List<String> canonicalValues = new ArrayList<>();
            prepStmt.setInt(1, claimId);
            prepStmt.setInt(2, tenantId);

            try (ResultSet rs = prepStmt.executeQuery()) {
                while (rs.next()) {
                    String claimPropertyName = rs.getString(SQLConstants.PROPERTY_NAME_COLUMN);
                    String claimPropertyValue = rs.getString(SQLConstants.PROPERTY_VALUE_COLUMN);
                    // Check if the property is a sub attribute, if so, add it to the sub attributes list and skip
                    // adding the single property to the map.
                    if (claimPropertyName.startsWith(SUB_ATTRIBUTE_PREFIX)) {
                        subAttributes.add(claimPropertyValue);
                        continue;
                    } else if (claimPropertyName.startsWith(CANONICAL_VALUE_PREFIX)) {
                        /* Check if the property is a canonical value. If so, add it to the canonical value list and
                           skip adding the single property to the map. */
                        canonicalValues.add(claimPropertyValue);
                        continue;
                    }

                    claimProperties.put(claimPropertyName, claimPropertyValue);
                }
                // If there are sub attributes, add them as a single property. All the sub attributes are separated by
                // a space.
                if (!subAttributes.isEmpty()) {
                    claimProperties.put(SUB_ATTRIBUTES_PROPERTY, StringUtils.join(subAttributes, " "));
                }
                // If there are canonical values, add them as a single property.
                if (!canonicalValues.isEmpty()) {
                    claimProperties.put(CANONICAL_VALUES_PROPERTY, canonicalValues.toString());
                }
            }
        } catch (SQLException e) {
            throw new ClaimMetadataException("Error while retrieving claim properties", e);
        }

        return claimProperties;
    }

    public void addClaimProperties(Connection connection, int claimId, Map<String, String> claimProperties,
            int tenantId) throws ClaimMetadataException {

        if (claimId > 0 && claimProperties != null) {
            String query = SQLConstants.ADD_CLAIM_PROPERTY;
            try (PreparedStatement prepStmt = connection.prepareStatement(query);) {
                prepStmt.setInt(1, claimId);
                prepStmt.setInt(4, tenantId);
                for (Map.Entry<String, String> property : claimProperties.entrySet()) {
                    if (StringUtils.equals(property.getKey(), SUB_ATTRIBUTES_PROPERTY)) {
                        String[] subAttributes = property.getValue().split(" ");
                        int subAttributeIndex = 0;
                        for (String subAttribute : subAttributes) {
                            subAttributeIndex++;
                            prepStmt.setString(2, SUB_ATTRIBUTE_PREFIX + subAttributeIndex);
                            prepStmt.setString(3, subAttribute);
                            prepStmt.addBatch();
                        }
                        continue;
                    } else if (StringUtils.equals(property.getKey(), CANONICAL_VALUES_PROPERTY)) {
                        try {
                            JSONArray canonicalValues = new JSONArray(property.getValue());
                            int canonicalValueIndex = 0;
                            for (int i = 0; i < canonicalValues.length(); i++) {
                                canonicalValueIndex++;
                                JSONObject canonicalValue = canonicalValues.getJSONObject(i);
                                prepStmt.setString(2, CANONICAL_VALUE_PREFIX + canonicalValueIndex);
                                prepStmt.setString(3, canonicalValue.toString());
                                prepStmt.addBatch();
                            }
                        } catch (JSONException e) {
                            log.warn("Error while parsing the canonical values JSON array. Hence, skipping "
                                    + "adding canonical values to the claim.", e);
                        }
                        continue;
                    }
                    prepStmt.setString(2, property.getKey());
                    prepStmt.setString(3, property.getValue());
                    prepStmt.addBatch();
                }
                prepStmt.executeBatch();
            } catch (SQLException e) {
                throw new ClaimMetadataException("Error while adding claim properties", e);
            }
        }
    }

    protected void deleteClaimProperties(Connection connection, int claimId, int tenantId)
            throws ClaimMetadataException {

        String query = SQLConstants.DELETE_CLAIM_PROPERTY;
        try (PreparedStatement prepStmt = connection.prepareStatement(query)) {
            prepStmt.setInt(1, claimId);
            prepStmt.setInt(2, tenantId);
            prepStmt.execute();
        } catch (SQLException e) {
            throw new ClaimMetadataException("Error while deleting claim properties", e);
        }
    }

    public int getIdOfClaim(Connection connection, String claimDialectURI, String claimURI, int tenantId) throws
            ClaimMetadataException {

        PreparedStatement prepStmt = null;
        ResultSet rs = null;

        int claimId = 0;
        String query = SQLConstants.GET_CLAIM_ID;
        try {
            prepStmt = connection.prepareStatement(query);
            prepStmt.setString(1, claimDialectURI);
            prepStmt.setInt(2, tenantId);
            prepStmt.setString(3, claimURI);
            prepStmt.setInt(4, tenantId);
            rs = prepStmt.executeQuery();

            while (rs.next()) {
                claimId = rs.getInt(SQLConstants.ID_COLUMN);
            }
        } catch (SQLException e) {
            throw new ClaimMetadataException("Error while retrieving ID for claim " + claimURI + " in dialect "
                    + claimDialectURI, e);
        } finally {
            IdentityDatabaseUtil.closeResultSet(rs);
            IdentityDatabaseUtil.closeStatement(prepStmt);
        }
        return claimId;
    }
}
